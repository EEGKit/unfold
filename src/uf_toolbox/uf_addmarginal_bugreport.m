function ufresult = uf_addmarginal(ufresult,varargin)
%% add the marginal of the other predictors (i.e. continuous & spline predictors) to the beta estimates
% Important: If dummy-coded (i.e. non-effect coded) predictors and
% interactions exist, they are NOT added to the marginal effect. I.e. the
% output of the method returns the average ERP evaluated at the average of
% all spline/continuous predictors, keeping the categorical/interaction
% structure untouched
%
% Arguments:
%   ufresult         unfold result structure generated by uf_condense()
%
% Optional arguments:
%   cfg.channel      (all) Calculate only for a subset of channels (numeric)
%   cfg.betaSetname  ("beta" = deconvolution model) string that indicates which unfold.(field) to use 
%                    (i.e. ufresult.beta for deconvolution vs. ufresult.beta_nodc for a massive univariate model)
%
% Example
% For instance the model 1 + cat(facA) + continuousB
%   has the betas: intercept, facA==1, continuousB-Slope
%
% The beta output of uf_condense(uf_glmfit) mean the following:
%   intercept: response with facA = 0 and continuousB = 0
%   facA==1  : differential effect of facA == 1 (against facA==0)
%   continuousB-slope: the slope of continous B
%
% Using uf_predictContinuous(), we evaluate the continuous predictor at [0 50 100]
% The beta output of uf_predictContinuous then mean the following:
%   intercept: same as before
%   facA==1  : same as before
%   continuousB@0  : the differential effect if continuous B is 0 
%   continuousB@50 : the differential effect if continuous B is 50
%   continuousB@100: the differential effect if continuous B is 100
%
% Using uf_addmarginal(), the average response is added to all predictors:
%
%   intercept: the response of facA==0 AND continuousB@mean(continuousB)
%   intercept: the response of facA==1 AND continuousB@mean(continuousB)
%   continuousB@0  : the response of facA==0 if continuous B is 0 
%   continuousB@50 : the response of facA==0 if continuous B is 50
%   continuousB@100: the response of facA==0 if continuous B is 100
%
% Note that mean(continuousB) does not need to be a number we evaluated in
% the uf_predictContinuous step

% parse inputs
cfg = finputcheck(varargin,...
    {'channel','integer',[],[]; ...
    'betaSetname','string','','' ...
    },'mode','ignore');

if(ischar(cfg)); error(cfg); end

% check whether the user tried to enter EEG.unfold directly into this 
% function (without running uf_condense() first)
if ~isfield(ufresult,'param') & isfield(ufresult,'unfold')
    error('\n%s(): You cannot directly enter the unfold output into this function - please run uf_condense() first', mfilename)
end

% In order to add the marginal, we need evaluated splines (uf_predictContinuous) first.
% Here we are looking for "spline_converted" or "continuous_converted" (in ufresult.param.type) 
% If any continuous predictors have not yet been evaluated, throw an error:
if any(strcmp({ufresult.param.type},'spline')) || any(strcmp({ufresult.param.type},'continous'))
    error('In order to add the marginals, you need to run uf_predictContinuous() first to evaluate the splines and continuous predictors at certain values');
end

% if no betaSetname was provided: apply uf_addmarginal() to all betas (recursive call)
if isempty(cfg.betaSetname)
    [betaSetname] = uf_unfoldbetaSetname(ufresult,varargin{:}); % get the appropriate field containing the betas
    
    % RECURSION ALERT!
    if length(betaSetname) > 1
        for b = betaSetname
            ufresult_tmp    = uf_addmarginal(ufresult,'betaSetname',b{1});
            ufresult.(b{1}) = ufresult_tmp.(b{1});
        end
        return
    else
        cfg.betaSetname = betaSetname{1};
    end
    % END OF RECURSION ALERT
end

fprintf('\n%s(): working on the data in the field \"%s\" \n',mfilename, cfg.betaSetname)

% determine number of channels
if isempty(cfg.channel)
    cfg.channel = 1:size(ufresult.(cfg.betaSetname),1);
end

% paramEventsUnique = unique([ufresult.param.event]); % N = 10 (???)
paramEvents       = [ufresult.param.event]; % length = 48, cause some contain many
paramNames        = {ufresult.param.name};  % length = 24

% make copy ufresult_avg
fprintf('\nRe-running uf_condense() to recover unconverted splines\n')
ufresult_avg = uf_condense(ufresult); % re-genererate, (without "evaluated" predictors)
ufresult_avg = uf_predictContinuous(ufresult_avg,'auto_method','average'); % get mean of continuous/spline predictors

%% go tru unique event types
for e = unique(paramEvents)
    
    % find indices where current event type (e.g., "123", "saccade", "fixation") exists in paramEvents
    % (note: this can be multiple times!)
    e_Idx = find(strcmp(e,paramEvents));
        
    % why?
    if length(e_Idx) == 1
        continue 
    end
            
    % ---------------------------------------------------------------------
    % Major Bug (2019-04-04): 
    % e_Idx is based on paramEvents, which can have substantially more entries than paramNames
    % creating an error here (index exceeded)
    % ---------------------------------------------------------------------
    % The following code was so obsfuscated that I was unable to debug
    % this...
    
    eventParamNames = paramNames(e_Idx);
    
    for p = unique(eventParamNames)
        
        % Find the names & types of the other parameters
        currEvent       = e_Idx(strcmp(p,eventParamNames));
        otherEvents     = setdiff(e_Idx,currEvent);
        otherParamNames = unique(paramNames(otherEvents));
        
        ufresultavg_ix  = [];
        for pOther = otherParamNames
            ufresultavg_ix(end+1) = find(strcmp(pOther{1},{ufresult_avg.param.name}));
        end
        
        % exclude all categorical predictors
        % (they should be covered by the effects/dummy coding schema already ?!)
        removeix = strcmp('categorical',{ufresult_avg.param(ufresultavg_ix).type});            % categorical?
        removeix = removeix | strcmp('interaction',{ufresult_avg.param(ufresultavg_ix).type}); % interaction?
        ufresultavg_ix(removeix) = []; % remove
        
        % calculate the marginal over all other predictors
        average_otherEffects = squeeze(sum(ufresult_avg.(cfg.betaSetname)(cfg.channel,:,ufresultavg_ix),3));
        
        % add this marginal to the current predictor
        ufresult.(cfg.betaSetname)(cfg.channel,:,currEvent) = ufresult.(cfg.betaSetname)(cfg.channel,:,currEvent) + repmat(average_otherEffects,1,1,length(currEvent));
    end
end