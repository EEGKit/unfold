<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Essential functions &#8212; Unfold EEG Toolbox</title>
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/doc_style.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootswatch-3.3.6/paper/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Website Data Privacy" href="impressum.html" />
    <link rel="prev" title="API" href="documentation.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

<!-- Matomo -->
<script type="text/javascript">
  var _paq = _paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['requireConsent']);
  _paq.push(['trackPageView']);
  _paq.push(['rememberConsentGiven']);
  _paq.push(['forgetConsentGiven']);:
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//www.unfoldtoolbox.org/piwik/";
    _paq.push(['setTrackerUrl', u+'piwik.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Matomo Code -->


  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html"><span><img src="_static/unfold_white_200x94.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="index.html">Home</a></li>
                <li><a href="http://github.com/unfoldtoolbox/unfold">Download from Github</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html"> <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="toolboxWorkflow.html">Unfold’s toolbox workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolboxWorkflow.html#minimal-data-specifications">Minimal Data Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolboxWorkflow.html#bad-missing-data">Bad &amp; Missing data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="toolboxWorkflow.html#removing-artifactual-data">Removing artifactual data</a></li>
<li class="toctree-l3"><a class="reference internal" href="toolboxWorkflow.html#imputation-of-missing-data">Imputation of missing data</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="toolboxWorkflow.html#massive-univariate-modeling-rerp">Massive univariate modeling (rERP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolboxWorkflow.html#toolbox-structure-fields-explained">Toolbox structure fields explained</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contenttutorials.html">Theoretical Background</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contenttutorials.html#introduction-to-linear-modeling">Introduction to linear modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="contenttutorials.html#why-deconvolution">Why deconvolution?</a></li>
<li class="toctree-l2"><a class="reference internal" href="contenttutorials.html#how-does-deconvolution-work">How does deconvolution work?</a></li>
<li class="toctree-l2"><a class="reference internal" href="contenttutorials.html#introduction-to-additive-spline-linear-modeling">Introduction to additive/spline linear modeling</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="toolboxtutorials.html">Tutorials / Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="toolbox-tut01.html">Quickstart: 2x2 ANOVA</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox-tut02.html">Longstart: 2x2 ANOVA</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox-tut03.html">Non-Linear Predictors using splines</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox-tut04.html">With and without deconvolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox-tut05.html">Time-Basis functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox-tut06.html">2nd level (group/subject) statistics</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="documentation.html">API</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Essential functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-cleaning">Data cleaning</a></li>
<li class="toctree-l2"><a class="reference internal" href="#massive-univariate-linear-modelling">Massive univariate linear modelling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#designmatrix-tools">Designmatrix-Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="#post-fit-tools">Post-Fit tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="#plotting">Plotting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#plot-events-designmatrix">plot events &amp; designmatrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plot-results">plot results</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="impressum.html">Website Data Privacy</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="contenttutorials.html">Theoretical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="toolboxtutorials.html">Tutorials / Examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="documentation.html">API</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Essential functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-cleaning">Data cleaning</a></li>
<li class="toctree-l2"><a class="reference internal" href="#massive-univariate-linear-modelling">Massive univariate linear modelling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#designmatrix-tools">Designmatrix-Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="#post-fit-tools">Post-Fit tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="#plotting">Plotting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#plot-events-designmatrix">plot events &amp; designmatrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plot-results">plot results</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="impressum.html">Website Data Privacy</a></li>
</ul>

        </div>
      </div>
    <div class="col-md-9 content">
      
  <span class="target" id="module-src.uf_toolbox"></span><div class="section" id="essential-functions">
<h1>Essential functions<a class="headerlink" href="#essential-functions" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="src.uf_toolbox.uf_designmat">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_designmat</code><span class="sig-paren">(</span><em>EEG</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_designmat" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Generate Designmatrix out of EEG.event structure and a formula</dt>
<dd>Input an EEG event structure and you will get an EEG.unfold.X field with
the designmatrix.If you add multiple eventtypess+formulas as cell-arrays, this function will iteratively
call itself and combine it to one big designmatrix.The designmatrix is not yet ready to do deconvolution, use
uf_timeexpandDesignmat for this.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cfg.formula</strong> (<em>string</em>) – <p>Formula in the wilkinson format. In addition to
the matlab default, one can specify ‘cat(X)’ so that X is interpreted as a
categorical variable and therefore dummy/effect-coded.
Also using spl(Y,5) defines a “non-linear” predictor
using 5 b-cubic spline basis functions. The more
splines one uses, the higher the risk of overfitting
but also of course more flexible relations can be
fitted. Custom spline functions are possible by using
uf_designmat_spline() after the initial call of
uf_designmat.</p>
<p>Example with multiple formulas: {‘y~A+spl(B,5)’, ‘y~x+cat(y)’,’y~1’}</p>
<p>Be sure to define multiple eventtypes if you use
multiple formulas.</p>
<p>Example with more complex formula:
{‘y ~ stimulus_type + color * size + stimulus_type:color}’</p>
<p>This formula would add the following main effects:
“stimulus_type, color, size”
and the following interactions:
“stimulus_type:color, color:size”</p>
<p>To define the reference category, have a look at
cfg.categorical {cell} down below. By default we sort
the levels and choose the first level as the reference</p>
</li>
<li><strong>cfg.eventtypes</strong> (<em>cell of strings or cell of cells of strings</em>) – the formula is fit on these
events. make sure that all fields are filled for all events
special-case: Multiple eventtypess
You can fit multiple different formulas on different events
concurrently. The specification could be as follows:
{{‘A1’,’A2’,’A3’},{‘B’},{‘C’}}.
If more than one formula are specified, we expect you to specify
the eventtypess each formula should be applied to.</li>
<li><strong>cfg.spline</strong> (<em>cell</em>) – define a b-spline non-parametric continuous effect. For example:
cfg.spline = {{‘speed’,15},{‘size’,10}};
This adds two non-parametric splines, speed with 15
knots and size with 10 knots, thus in total 14+9=23
parameters (we remove one spline due to the Linear
Modeling aspect). Can be specified more conveniently
directly inside the formula
2D splines have to be specified in the form {‘xpos’,’ypos’,10}</li>
<li><strong>cfg.categorical</strong> (<em>cell-array</em>) – default {}, list of which of the EEG.event fields
should be treated as an categorical effect (thus
dummy/effect coded). You can also directly specify what
variables are categorical in the formula.
You can specify the order of the predictors. For
example:
{‘predictorA’,{‘level3’,’level1’,’level2’}; ‘predictorB’,{‘level2’,’level1’}}
For predictorA, the level3 is now used as a reference
group. For predictorB the level2 is now used.
The second column of the cell array is optional. E.g.
{‘predictorA’,’predictorB’} will make both predictors
as categorical</li>
<li><strong>cfg.splinespacing</strong> (<em>string</em>) – defines how the knots of the splines should be
placed. Possible values:
‘linear’ : linear spacing with boundary splines at the respective min/max
‘log’: logarithmic increasing spacing
‘logreverse’: log decreasing spacing
‘quantiles’ (default): heuristic spacing at the quantiles</li>
<li><strong>cfg.codingschema</strong> (<em>string</em>) – default: ‘references’, could be ‘effects’, this is
relevant if you define categorical input variables.
Reference coding is also known as treatment coding</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>Returns the EEG structure with the additional fields in EEG.unfold</p>
<ul class="simple">
<li>X:          The design matrix</li>
<li>colnames:     For each column of ‘X’, which predictor it represents</li>
<li>formula:    The original cfg.formula</li>
<li>event:      the cfg.eventtypes</li>
<li>cols2eventtypes:   For each column of ‘X’ which event it represents</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">EEG-struct</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><em>Example:</em></dt>
<dd>A classical 2x2 factorial design with interaction</dd>
</dl>
<div class="line-block">
<div class="line">cfgDesign = [];</div>
<div class="line">cfgDesign.eventtypes = {‘fixation’};</div>
<div class="line">cfgDesign.formula = ‘y ~ 1 + cat(level_predictability)*cat(target_fixation)’;</div>
<div class="line"><br /></div>
<div class="line">Specifying the reference category</div>
<div class="line">cfgDesign = [];</div>
<div class="line">cfgDesign.eventtypes = {‘fixation’};</div>
<div class="line">cfgDesign.formula = ‘y ~ cat(level_predictability)*cat(target_fixation)+ 1’;</div>
<div class="line">cfgDesign.categorical = {‘level_predictability’,{‘low’,’high’};      % level low   is reference</div>
<div class="line-block">
<div class="line">‘target_fixation’,     {‘early’,’late’}};   % level early is reference</div>
<div class="line"><br /></div>
</div>
<div class="line">Adding spline and multiple events</div>
<div class="line">This extends the above example by two cases: A) We add a non-parametric</div>
<div class="line-block">
<div class="line">spline (n = 10) for the saccade amplitude B) We add a second formula</div>
<div class="line">for a second event (StimOnset1/2) that only contains a constant (y~1).</div>
<div class="line"><br /></div>
</div>
<div class="line">Second Example</div>
<div class="line">This extends the above example by two cases:</div>
<div class="line-block">
<div class="line"><strong>A)</strong> We add non-parametric splines (n = 10) for the X and Y position of the current fixation.</div>
<div class="line"><strong>B)</strong> We add a second formula for a second event (StimOnset1/2) that only</div>
</div>
<div class="line">contains a constant (y~1).</div>
<div class="line"><br /></div>
<div class="line">cfgDesign = [];</div>
<div class="line">cfgDesign.eventtypes = {{‘fixation’},{‘StimOnset1’,’StimOnset2’}};</div>
<div class="line">cfgDesign.formula = {‘y ~ 1 + cat(level_predictability)*cat(target_fixation) + spl(sac_amplitude,10)’,’y~1’};</div>
<div class="line"><br /></div>
<div class="line">EEG = uf_addDesignmat(EEG,cfgDesign);</div>
</div>
</dd></dl>

<dl class="function">
<dt id="src.uf_toolbox.uf_timeexpandDesignmat">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_timeexpandDesignmat</code><span class="sig-paren">(</span><em>EEG</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_timeexpandDesignmat" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Timeexpand Designmatrix.</dt>
<dd>This function takes the designmatrix% (saved in EEG.unfold.X, a
EEG.points times nPredictor matrix) and expands it
over time (in the range of the windowlength).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cfg.method</strong> (<em>string</em>) – <p>default ‘stick’; Three methods are available:</p>
<ul>
<li>’stick’      We shift the signal over each point in time, uses the stickfunction basis</li>
<li>’splines’    We use cubic splines (number = Timeexpandparam) to approximate the signal. This makes use of neighbouring timepoints that are very likely correlated.</li>
<li>’fourier’    We use a fourier set (up to the first Timeexpandparam frequencies) to model the signal.</li>
</ul>
</li>
<li><strong>cfg.timelimits</strong> (<em>2 integer</em>) – defines over what time the timeexpand should go, this is
analog to the epoch-size. This should be as long, as you think
overlap can happen in your data (in seconds)</li>
<li><strong>cfg.timeexpandparam</strong> (<em>integer</em>) – depending on whether cfg.method is splines or fourier defines how
many splines or fourier frequencies (in case of fourier, the
effective parametersize is twice as large due to the sin/cos ‘duplication’) should be used
to convolve. In case of ‘full’, the parameter is not used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li>EEG.unfold.Xdc - the designmatrix for all time points</li>
<li>EEG.unfold.timebasis - the basis set for splines / fourier. This is used later to recover the values in the time-domain, not the basis-function domain</li>
<li>EEG.unfold.basisTime - the time of the unfold-window in seconds</li>
<li>EEG.Xdc_terms2cols - A unique specifier defining which of the deconvolution-additional-columns belongs to which predictor</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><em>Example:</em></dt>
<dd>EEG = uf_timeexpandDesignmat(EEG,’method’,’splines’,’windowlength’,128,’timeexpandparam’,30)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="src.uf_toolbox.uf_glmfit">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_glmfit</code><span class="sig-paren">(</span><em>EEG</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_glmfit" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Fit the fullX designmatrix on the data and returns beta and stats</dt>
<dd>This function solves the Equation X*beta = EEG.data, with X = Designmat.
There are multiple algorithms implemented, a slow iterative algorithm
that runs on sparse matrices (default) that solves each channel in turn
and the matlab algorithm which solves all channels at the same time, but
take quite a lot of memory.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cfg.method</strong> (<em>string</em>) – <ul>
<li>“lsmr”      default; an iterative solver is used, this is</li>
</ul>
<p>very memory efficient, but is a lot slower than the ‘time’ option
because each electrode has to be solved independently. The LSMR
algorithm is used for sparse iterative solving.</p>
<ul>
<li>”par-lsmr”  same as lsmr, but uses parfor with ncpu-1. This does not</li>
</ul>
<p>seem to be any faster at the moment (unsure why). Not recommended</p>
<ul>
<li>”matlab”    , uses matlabs native A/b solver. For moderate to big</li>
</ul>
<p>design-matrices it will need <em>a lot</em> of memory (40-60GB is easily
reached)</p>
<ul>
<li>”pinv”      A naive pseudo-inverse, generally not recommended due to</li>
</ul>
<p>floating point instability</p>
<ul>
<li>”glmnet”    uses glmnet to fit the linear system. This by default uses</li>
</ul>
<p>L1-Norm aka lasso (specified as cfg.glmnetalpha = 1). For
ridge-regression (L2-Norm) use (cfg.glmnetalpha = 0). Something
inbetween results in elastic-net. We use the cvglmnet functionality
that automatically does crossvalidation to estimate the lambda
parameter (i.e. how strongly parameter values should be regularised
compared to the fit of the model). We use the glmnet recommended
‘lambda_1se’, i.e. minimum lambda + 1SE buffer towards more strict
regularisation.</p>
</li>
<li><strong>cfg.lsmriterations</strong> – (default 400), defines how many steps the iterative
solver should search for a solution. While the solver is mostly monotonic (see paper), it is recommended
to increase the iterations. A limit is only defined because in our experience, high number of iterations
are a result of strong collinearities, and hint to a faulty model</li>
<li><strong>cfg.glmnetalpha</strong> – (default 1, as in glmnet), can be 0 for L2 norm, 1 for L1-norm or
something inbetween for elastic net</li>
<li><strong>cfg.channel</strong> (<em>array</em>) – Restrict the beta-calculation to a subset of
channels. Default is all channels</li>
<li><strong>cfg.debug</strong> (<em>boolean</em>) – 0, only with method:matlab, outputs additional
details from the solver used</li>
<li><strong>cfg.precondition</strong> (<em>boolean</em>) – 1, scales each row of Xdc to SD=1. This
increase the solving speed by factor ~2. For very large
matrices you might run into memory problems. Deactivate
then.</li>
<li><strong>EEG</strong> – the EEG set, need to have EEG.unfold.Xdc compatible with
the size of EEG.data</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">array (nchan x ntime x npred) (ntime could be
n-timesplines, n-fourierbasis or samples)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">EEG.unfold.beta</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><em>Example:</em></dt>
<dd>EEG = dc_glmfit(EEG);
EEG = dc_glmfit(EEG,’method’,’matlab’,’channel’,[3 5]);</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="src.uf_toolbox.uf_condense">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_condense</code><span class="sig-paren">(</span><em>EEG</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_condense" title="Permalink to this definition">¶</a></dt>
<dd><p>Condense results in new structure. Apply timebasis (if necessary)
Returns an “ufresult”-struct that contains the predictor betas over time
and accompanying information. This structure is further used in all
plotting functions. This function also applys the timebasis (if you
specified something else than the default ‘stick’ in
uf_timeexpandDesignmat()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>EEG</strong> (<em>struct</em>) – A Struct containing EEG.unfold.beta_dc</li>
<li><strong>cfg.deconv</strong> (<em>integer</em>) – 1, use EEG.unfold.beta_dc, the deconvolved betas
0, use EEG.unfold.beta_nodc, betas without
deconvolution
-1 (default), autocheck which fields are avaiable
and returns both</li>
<li><strong>cfg.channel</strong> (<em>array</em>) – Restrict the beta-output to a subset of
channels. Default is all channels</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">ufresult.beta= (nchans x time x parameters)
ufresult.beta_nodc = (nchans x time x parameters) (only if unfold=0 or -1)
ufresult.param = (struct size: parameters) each field contains the values of the respective parameter.
ufresult.unfold = EEG.unfold
ufresult.times = EEG.times
ufresult.chanlocs = EEG.chanlocs</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<p>ufresult = uf_condense(EEG)</p>
<p>ufresult.param(X):</p>
<ul class="simple">
<li>name: name of the variable, e.g.: ‘continuousA’</li>
<li>value: value of the predictor, e.g. ‘50’</li>
<li>event: event of the variable, e.g.: ‘eventA’</li>
</ul>
</dd></dl>

</div>
<div class="section" id="data-cleaning">
<h1>Data cleaning<a class="headerlink" href="#data-cleaning" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="src.uf_toolbox.uf_continuousArtifactDetect">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_continuousArtifactDetect</code><span class="sig-paren">(</span><em>EEG</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_continuousArtifactDetect" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Reject commonly recorded artifactual potentials (c.r.a.p.)</dt>
<dd><p class="first">This function has been altered very much by Benedikt Ehinger
I removed all the filter-features
I changed the input parser.</p>
<p>There are a number of common artifacts that you will see in nearly every EEG data file. These
include eyeblinks, slow voltage changes (caused mostly by skin potentials), muscle activity
(from moving the head or tensing up the muscles in the face or neck), horizontal eye movements,
and various types of C.R.A.P. (Commonly Recorded Artifactual Potentials).</p>
<p>Although we usually perform artifact rejection on the segmented data, it’s a good idea to
examine the raw unsegmented EEG data first. You can usually identify patterns of artifacts,
make sure there were no errors in the file, etc., more easily with the raw data [1].</p>
<p class="last">crap.m allows you to automatically identify large peak-to-peak differences or extreme amplitude
values, within a moving window, across your continuous EEG dataset. After performing crap.m,
artifactual segments will be rejected and replaced by a ‘boundary’ event code.</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>EEG</strong> – <ul>
<li>continuous EEG dataset (EEGLAB’s EEG structure)</li>
</ul>
</li>
<li><strong>'amplitudeThreshold'</strong> – <ul>
<li>Thresolds ( values). [-lim +lim] is marked</li>
</ul>
</li>
<li><strong>'windowsize'</strong> – <ul>
<li>moving window width in msec (default 2000 ms)</li>
</ul>
</li>
<li><strong>'stepsize'</strong> – <ul>
<li>moving window step (default 1000 ms)</li>
</ul>
</li>
<li><strong>'combineSegements'</strong> – <ul>
<li>marked segment(s) closer than this value will be joined together.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<p>winrej = uf_continuousArtifactDetect(EEG)</p>
<dl class="docutils">
<dt>Reference:</dt>
<dd><p class="first">ERP Boot Camp: Data Analysis Tutorials. Emily S. Kappenman, Marissa L. Gamble, and Steven J. Luck. UC Davis</p>
<p class="last">This function is part of ERPLAB Toolbox
Author: Javier Lopez-Calderon
Center for Mind and Brain
University of California, Davis,
Davis, CA
2009</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="src.uf_toolbox.uf_continuousArtifactExclude">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_continuousArtifactExclude</code><span class="sig-paren">(</span><em>EEG</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_continuousArtifactExclude" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Function to exclude (artifactual) continuous data from being modeled</dt>
<dd>This function inputs a rejection vector and excludes the content from
being modeled in the design matrix. That means it sets all predictor
values at the given times to 0.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cfg.winrej</strong> (<em>integer</em>) – A (2xn) array with n from-to pairs of samples to</li>
<li><strong>excluded from further processing This is the same output as from</strong> (<em>be</em>) – </li>
<li><strong>eegplot rej</strong> (<em>EEGlabs'</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>EEG-Structure</p>
<ul class="simple">
<li>unfold.X: All elements between the from-to pairs got set to 0</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<p>We want to exclude three sections that are supposedly artifactual</p>
<div class="line-block">
<div class="line">cfgReject = [];</div>
<div class="line">cfgReject.winrej = [10,50; 100,120; 300,310];</div>
<div class="line">EEG = uf_artefactRemoveDesignmat(cfgReject,EEG)</div>
</div>
</dd></dl>

</div>
<div class="section" id="massive-univariate-linear-modelling">
<h1>Massive univariate linear modelling<a class="headerlink" href="#massive-univariate-linear-modelling" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="src.uf_toolbox.uf_epoch">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_epoch</code><span class="sig-paren">(</span><em>EEG</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_epoch" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Epoch the data according to the unfold structure</dt>
<dd>Deconvolution works on continuous data, thus to compare it to the
“normal” use-case, we have to epoch it. Because the data has not been
cleaned yet, we do this in this function. We additionally remove trials
from unfold.X that were removed during epoching.
Afterwards you can use uf_glmfit_nodc to fit the model</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cfg.winrej</strong> (<em>integer</em>) – A (2xn) array with n from-to pairs of samples to be excluded from further processing</li>
<li><strong>cfg.timelimits</strong> (<em>float</em>) – min+max of the epoch in seconds</li>
<li><strong>EEG</strong> (<em>eeglab</em>) – the EEG set, need to have EEG.unfold.Xdc compatible with the size of EEG.data</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Epoched EEG file to cfg.timelimits</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><em>Example:</em></dt>
<dd>EEG_epoch = uf_epoch(EEG,’winrej’,winrej,’timelimits’,cfgTimeexpand.timelimits)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="src.uf_toolbox.uf_glmfit_nodc">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_glmfit_nodc</code><span class="sig-paren">(</span><em>EEG</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_glmfit_nodc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>A function to solve the inverse problem without deconvolution</dt>
<dd><p class="first">Simple function to do massive univariate linear model. The function
expects EEG.data to be (CHAN,TIME,EPOCH) with EPOCH the same number as
EEG.unfold.X.</p>
<p class="last">It is recommended to use uf_epoch for epoching, because you need to remove rows
from EEG.unfold.X if the epoching function removed trials. Also cleaning
of data is taken care of in uf_epoch</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cfg.method</strong> – (default pinv) ‘glmnet’,’pinv’,’matlab’,’lsmr’ are available. See
the uf_glmfit function for further information. By making use of
pinv, the linear model needs to be solved only once and can be
applied to all electrodes. The other solves iteratively solve for
each electtrode.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Returns a matrix (channel x pnts x predictors) of betas saved into
EEG.devon.beta</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><em>Example:</em></dt>
<dd>EEG = uf_glmfit_nodeconv(EEG)</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="designmatrix-tools">
<h1>Designmatrix-Tools<a class="headerlink" href="#designmatrix-tools" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="src.uf_toolbox.uf_imputeMissing">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_imputeMissing</code><span class="sig-paren">(</span><em>EEG</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_imputeMissing" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Impute Missing Values</dt>
<dd>Deal with predictors for which some values are missing in design matrix
You can either impute missing values or remove the predictors events for
which some values are missing</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cfg.method</strong> – <ul class="simple">
<li><dl class="first docutils">
<dt>‘drop’ <span class="classifier-delimiter">:</span> <span class="classifier">(similar to R) Drop the whole event from the designmat (fill</span></dt>
<dd>it with 0). This will lead to the event not being used
for overlap correction!</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>’marginal’ <span class="classifier-delimiter">:</span> <span class="classifier">fill in a random value from the marginal predictor-distribution</span></dt>
<dd>in the future it might be interesting to implement not the
marginal, but multivariate methods to conservate
correlations between predictors (c.f. Horton &amp; Kleinmann 2007)</dd>
</dl>
</li>
<li>’mean’     : fill in the mean value</li>
<li>’median’   : (Default) fill in the median value</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">EEG.unfold.X in which missing NAN-values were imputed (‘marginal’, ‘mean’,
‘median’) or in which the events with missing predictor information were
removed (‘drop’), which means put to 0</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<p>EEG = uf_imputeMissing(EEG)</p>
</dd></dl>

<dl class="function">
<dt id="src.uf_toolbox.uf_designmat_addcol">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_designmat_addcol</code><span class="sig-paren">(</span><em>EEG</em>, <em>newrow</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_designmat_addcol" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Adds a single custom column to the unfold-Designmat “Xdc”. This is</dt>
<dd>sometimes useful to add e.g. continuous predictors manually.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>newrow</strong> (<em>array</em>) – The column to add to the Xdc designmat</li>
<li><strong>label</strong> (<em>string</em>) – The label/identifier of the column</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">EEG-Struct
* unfold.Xdc added column
* unfold.colnames added label</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.uf_toolbox.uf_designmat_spline">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_designmat_spline</code><span class="sig-paren">(</span><em>EEG</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_designmat_spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to generate spline-part of designmatrix</p>
<dl class="docutils">
<dt>Argument:</dt>
<dd><dl class="first last docutils">
<dt>cfg.name(string): (optional, default: “spline_default”) A name for the</dt>
<dd>spline predictor</dd>
<dt>cfg.paramValues(double): The values of the predictor on which the</dt>
<dd>splines should be calculated and evaluated.
E.g. [-3 4,1,2,3, … 4]</dd>
<dt>cfg.nsplines(integer): number of splines to use. too many lead to</dt>
<dd>overfitting, to few to underfitting</dd>
<dt>cfg.knotsequence(real): optional (if nsplines is specified). Give the</dt>
<dd>sequence of knots explicitly (else they are put on the
quantiles or linearly (see splinespacing). An example would
be [0,1,2,3,5,10,11,12,13]. This example could make sense
if there is lots of data at predictor 0-5 and again at
10-13.  To define the knotsequence explicitly is also
useful when you directly want to estimate the same betas
for all subjects. But beware of subject-specific ranges, not all
subjects have the same range in their covariates.</dd>
<dt>cfg.splinespacing(string): (quantile) linear or quantile. The spacing</dt>
<dd>of the knots along the</dd>
<dt>cfg.splinefunction (functionhandle): You can specify your own spline</dt>
<dd>function. This in principle also allows to make use of polynomial
regression</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>EEG structure</dt>
<dd><ul class="first last simple">
<li>unfold.X: new entries for the spline</li>
<li>unfold.splines: new entrie for the spline</li>
<li>in addition update to unfold: colnames, variablenames,cols2variablenames,cols2eventtypes,variabletypes</li>
</ul>
</dd>
</dl>
<p>spl: Same as EEG.unfold.spline{end}
nanlist: the paramValues that were nan (same as ‘isnan(spl.paramValues)’ )</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<p>EEG = dc_designmat_spline(EEG,’name’,’splineA’,’paramValues’,[EEG.event.splineB],’nsplines’,10,’splinespacing’,’linear’);
EEG = dc_designmat_spline(EEG,’name’,’splineB’,’paramValues’,[EEG.event.splineB],’knotsequence’,linspace(0,2*pi,15),’splinefunction’,’cyclical’);</p>
</dd></dl>

</div>
<div class="section" id="post-fit-tools">
<h1>Post-Fit tools<a class="headerlink" href="#post-fit-tools" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="src.uf_toolbox.uf_predictContinuous">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_predictContinuous</code><span class="sig-paren">(</span><em>ufresult</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_predictContinuous" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates a continuous/spline parameter at specific values
This is similar to a predict function, but does not add the marginal of
the other parameters. For this please make use of uf_addmarignals().</p>
<p>Because model-estimates / parameters are defined for each time-point&amp;electrode and can
also encompass multiple betas (in the case of splines), this
becomes non trivial and thus this function.
Note that this will overvwrite the ufresult.beta field</p>
</dd></dl>

<dl class="function">
<dt id="src.uf_toolbox.uf_addmarginal">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_addmarginal</code><span class="sig-paren">(</span><em>ufresult</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_addmarginal" title="Permalink to this definition">¶</a></dt>
<dd><p>add the marginal of the other predictors (i.e. continuous &amp; spline predictors) to the beta estimates.
Important: If dummy-coded (i.e. non-effect coded) predictors and
interactions exist, they are NOT added to the marginal effect. I.e. the
output of the method returns the average ERP evaluated at the average of
all spline/continuous predictors, keeping the categorical/interaction
structure untouched.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cfg.channel</strong> – (all) Calculate only for a subset of channels (numeric)</li>
<li><strong>cfg.betaSetname</strong> – (“beta”) string that indicates which unfold.(field) to use</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example
For instance the model 1 + cat(facA) + continuousB
has the betas: intercept, facA==1, continuousB-Slope</p>
<p>The beta output of uf_condense(uf_glmfit) mean the following:
intercept: response with facA = 0 and continuousB = 0
facA==1  : differential effect of facA == 1 (against facA==0)
continuousB-slope: the slope of continous B</p>
<p>Using uf_predictContinuous, we evaluate the continuous parameter at [0 50 100]
The beta output of uf_predictContinuous mean the following:
intercept: same as before
facA==1  : same as before
continuousB&#64;0  : the differential effect if continuous B is 0
<a class="reference external" href="mailto:continuousB&#37;&#52;&#48;50">continuousB<span>&#64;</span>50</a> : the differential effect if continuous B is 50
<a class="reference external" href="mailto:continuousB&#37;&#52;&#48;100">continuousB<span>&#64;</span>100</a>: the differential effect if continuous B is 100</p>
<p>Using uf_addmarginal, the average response is added to all predictors.</p>
<p>intercept: the response of facA==0 AND continuousB&#64;mean(continuousB)
intercept: the response of facA==1 AND continuousB&#64;mean(continuousB)
continuousB&#64;0  : the response of facA==0 if continuous B is 0
<a class="reference external" href="mailto:continuousB&#37;&#52;&#48;50">continuousB<span>&#64;</span>50</a> : the response of facA==0 if continuous B is 50
<a class="reference external" href="mailto:continuousB&#37;&#52;&#48;100">continuousB<span>&#64;</span>100</a>: the response of facA==0 if continuous B is 100</p>
<p>Note that mean(continuousB) does not need to be a number we evaluated in
the uf_predictContinuous step.</p>
</dd></dl>

<dl class="function">
<dt id="src.uf_toolbox.uf_unfold2csv">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_unfold2csv</code><span class="sig-paren">(</span><em>ufresult</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_unfold2csv" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Exports betas in an organized csv file to be opened in another tool</dt>
<dd>returns a data-table</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cfg.deconv</strong> (<em>boolean</em>) – Use the unfold betas (unfold.beta_dc) or the
no-unfold betas(unfold.beta_nodc)</li>
<li><strong>cfg.channel</strong> (<em>integer</em>) – (Default: All channels) Limit to a list of specific channels</li>
<li><strong>cfg.filename</strong> – filename for the csv file. if empty, only returns table</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Each observation (voltage/beta) has one row, channels, predictors etc.
gets one column</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Data-Table in the “tidy”-format</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<p>uftable = uf_unfold2csv(ufresult,’filename’,’output.csv’)</p>
</dd></dl>

</div>
<div class="section" id="plotting">
<h1>Plotting<a class="headerlink" href="#plotting" title="Permalink to this headline">¶</a></h1>
<div class="section" id="plot-events-designmatrix">
<h2>plot events &amp; designmatrix<a class="headerlink" href="#plot-events-designmatrix" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="src.uf_toolbox.uf_plotEventCorrmat">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_plotEventCorrmat</code><span class="sig-paren">(</span><em>EEG</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_plotEventCorrmat" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Plots a correlation matrix of the event structure</dt>
<dd>Its possible to subselect the eventtype
Planned feature: allow to plot only the EEG.unfold.X field</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>eventtypes</strong> (<em>cell</em>) – Subselect the eventtypes, by default chooses all</li>
<li><strong>figure</strong> (<em>0/1</em>) – whether the corrmat should be plotted (default) or only
returned</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">correlationMatrix</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<p>uf_plotEventCorrmat(EEG)</p>
</dd></dl>

<dl class="function">
<dt id="src.uf_toolbox.uf_plotEventHistogram">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_plotEventHistogram</code><span class="sig-paren">(</span><em>EEG</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_plotEventHistogram" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Function that plots histogram of all events in the EEG.event structure</dt>
<dd>This function also adds a density estimate</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cfg.eventtypes</strong> – Restrict the histogram to a specific eventtypes</td>
</tr>
</tbody>
</table>
<p>Return:</p>
<dl class="docutils">
<dt><em>Example:</em></dt>
<dd>uf_plotEventHistogram(EEG,’eventA’)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="src.uf_toolbox.uf_plotDesignmat">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_plotDesignmat</code><span class="sig-paren">(</span><em>EEG</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_plotDesignmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the designmatrix
If the matrix is very large (the timeexpanded/Xdc matrix) we do not plot
everything, but only the middle 60s. In addition (for timeexpand) we plot
the events as horizontal lines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cfg.timeexpand'</strong> (<em>boolean</em>) – 0: Plots EEG.unfold.X (default)
1: Plots EEG.unfold.Xdc</li>
<li><strong>cfg.logColor</strong> (<em>boolean</em>) – plot the color on logscale (default 0)</li>
<li><strong>cfg.sort</strong> (<em>boolean</em>) – Sort the designmatrix (only possible for X, not Xdc)</li>
<li><strong>cfg.figure</strong> (<em>1/0</em>) – Open a new figure (default 1)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><em>Example:</em></dt>
<dd>uf_plot_designmat(EEG)
uf_plot_designmat(EEG,’sort’,1)
uf_plot_designmat(EEG,’timeexpand’,1) %plot the timeexpanded X</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="plot-results">
<h2>plot results<a class="headerlink" href="#plot-results" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="src.uf_toolbox.uf_plotParam">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_plotParam</code><span class="sig-paren">(</span><em>ufresult</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_plotParam" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Plots time vs. Voltage in separate plots for each predictor, where there</dt>
<dd><p class="first">are multiple lines for each predictor</p>
<p>‘ufresult’ needs to have the ‘ufresult’ structure, the output from
“uf_condense”</p>
<p class="last">Uses the ‘gramm’-toolbox for plotting</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>'channel'</strong> (<em>integer</em>) – Which channel to plot</li>
<li><strong>'predictAt'</strong> (<em>cell</em>) – a cell of cell arrays, e.g. {{‘parName’,linspace(0,10,5)},{‘parname2’,1:5}}
This is a shortcut to uf_continuousPredict. We generally
recommend to explicitly use the uf_continuousPredict function.</li>
<li><strong>'deconv'</strong> (<em>[-1 0 1]</em>) – default: -1; whether to plot ufresult.beta (1) or
ufresult.beta_nodc(0) or everything/autodetect (-1). Autodetect would
also detect same-shaped other predictors. If e.g. you want to compare
multiple runs from different algorithms or similar</li>
<li><strong>'add_intercept'</strong> (<em>boolean</em>) – Add the intercept/constant to each subplot.
This will give ERP-plots that are commonly used. Without add_intercepts the factors (if they are categorical) could be interpretet as difference or sometimes main effect plots (if effects-coding is used)</li>
<li><strong>'baseline'</strong> (<em>2 integers</em>) – default none; Performs a baseline corrections on the interval (in seconds = ufresult.times units) given.</li>
<li><strong>'include_intercept'</strong> (<em>boolean</em>) – default 0; useful with “add_intercept”, will add the constant/intercept to each subplot</li>
<li><strong>'plotSeparate'</strong> (<em>'all','event','none'</em>) – Each predictor will be
plotted in a separate figure (‘all’), plotted in an event-specific
figure (‘event’) or all subplots are in the same figure (‘none’, default)</li>
<li><strong>'plotParam'</strong> (<em>string/cell of strings</em>) – Defines which parameters are to be plotted</li>
<li><strong>'sameyaxis'</strong> (<em>'all','row','independent'</em>) – Force the same y-axis
(default ‘all’)</li>
<li><strong>'gramm'</strong> – (gramm-object) plots the current data ontop of the last gramm-object. This is
useful to plot multiple subjects in a single figure.</li>
<li><strong>'figure'</strong> (<em>boolean</em>) – Generate a new figure? (default 1)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">All ‘subplot’ axes that were generated</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">allAxesInFigure</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Example</dt>
<dd>uf_plotParam(ufresult,’channel’,1)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="src.uf_toolbox.uf_plotParam2d">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_plotParam2d</code><span class="sig-paren">(</span><em>ufresult</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_plotParam2d" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Plots a 2D plot of parameter vs. time with the predicted value as the</dt>
<dd>third dimension
This function plots an imagesc plot of time vs. parameter of choice</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>'plotParam'</strong> – Name of parameter to be plotted. can be empty to plot
all splines/continuous parameters</li>
<li><strong>'add_intercept'</strong> – add the intercept to the plot, default 0</li>
<li><strong>'channel'</strong> – Specify which channel-idx to plot</li>
<li><strong>'betaSetName'</strong> – Default ‘beta’. Can be any field of the ufresult-struct</li>
<li><strong>'caxis'</strong> – Default [], specify coloraxis</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example:
uf_plotParam2d(‘plotParam’,’continuosPredictorA’)</p>
</dd></dl>

<dl class="function">
<dt id="src.uf_toolbox.uf_plotParamTopo">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_plotParamTopo</code><span class="sig-paren">(</span><em>ufresult</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_plotParamTopo" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Generates rows of topoplots over time. each row is a predictor</dt>
<dd>If you are not interested in differences, but the predicted cells, it
might be helpful to run dc_addmarginal() before. Then you do not only
plot the simple/main effect, but the intercept is added to the difference
resulting in both condition.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>'plotParam'</strong> – cell array of parameters to be plotted, if empty plots all</li>
<li><strong>'n_topos'</strong> – <ol class="arabic" start="15">
<li>number of topographies to plot</li>
</ol>
</li>
<li><strong>'channel'</strong> – plot only a subset of channels</li>
<li><strong>'baseline'</strong> (<em>2 integers</em>) – default none; Performs a baseline corrections on the interval (in seconds = ufresult.times units) given.</li>
<li><strong>('same',default</strong> (<em>'caxis'</em>) – []) if ‘same’, generates the same coloraxis based
on the 95% percentile of the selected beta-values. can be
customized to whichever caxis e.g. [-3 5]</li>
<li><strong>'betaSetName'</strong> – Default ‘beta’. Can be any field of the ufresult-struct</li>
<li><strong>'figure'</strong> – plot in new figure (1) or old (0), default: (1)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">structure of all plotting axes.</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><em>Examples:</em></dt>
<dd>uf_plotParamTopo(EEG,’plotParam’,{‘FactorX’,’FactorC’})</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="src.uf_toolbox.uf_plot2nd">
<code class="descclassname">src.uf_toolbox.</code><code class="descname">uf_plot2nd</code><span class="sig-paren">(</span><em>d2nd</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#src.uf_toolbox.uf_plot2nd" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Preliminary function to plot multiple subjects (2nd-level analysis)</dt>
<dd><p class="first">This function allows to plot multiple subjects at the same time
the function requires the data to be in the following format:
ufresult.beta(CHAN,TIME,PARAM,SUBJECT)</p>
<p class="last">Each line is one subject, its possible to calculate confidence intervals</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cfg.channel</strong> – Which channel to use</li>
<li><strong>cfg.plotParam</strong> – (default 1, as in glmnet), can be 0 for L2 norm, 1 for L1-norm or
something inbetween for elastic net</li>
<li><strong>cfg.bootci</strong> – (default 1) calculate and plot boostraped confidence intervals</li>
<li><strong>cfg.singlesubjects</strong> – (default 1) plot the singlesubject lines</li>
<li><strong>...</strong> – Other parameters are linked to uf_plotParam</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">nothing</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<p>uf_plot2nd(ufresult2nd,’channel’,2)</p>
</dd></dl>

</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2018, Benedikt Ehinger, Olaf Dimigen.<br/>
      Last updated on Jun 04, 2018.<br/>
    </p>
  </div>
</footer>
  </body>
</html>